<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.Conc.Class</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-Conc-Class.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Monad-Conc-Class.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">dejafu-0.0.0.0: Overloadable primitives for testable, potentially non-deterministic, concurrency.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Control.Monad.Conc.Class</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module captures in a typeclass the interface of concurrency
 monads.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> Monad m =&gt; <a href="#t:MonadConc">MonadConc</a> m  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:STMLike">STMLike</a> m :: * -&gt; *</li><li><span class="keyword">type</span> <a href="#t:CVar">CVar</a> m :: * -&gt; *</li><li><a href="#v:fork">fork</a> :: m () -&gt; m ()</li><li><a href="#v:spawn">spawn</a> ::  m a -&gt; m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)</li><li><a href="#v:newEmptyCVar">newEmptyCVar</a> ::  m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)</li><li><a href="#v:putCVar">putCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m ()</li><li><a href="#v:tryPutCVar">tryPutCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m Bool</li><li><a href="#v:readCVar">readCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a</li><li><a href="#v:takeCVar">takeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a</li><li><a href="#v:tryTakeCVar">tryTakeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m (Maybe a)</li><li><a href="#v:atomically">atomically</a> ::  <a href="Control-Monad-Conc-Class.html#t:STMLike">STMLike</a> m a -&gt; m a</li><li><a href="#v:_concNoTest">_concNoTest</a> ::  m a -&gt; m a</li></ul></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> Monad m =&gt; <a name="t:MonadConc" class="def">MonadConc</a> m  <span class="keyword">where</span><a href="src/Control-Monad-Conc-Class.html#MonadConc" class="link">Source</a></p><div class="doc"><p><code>MonadConc</code> is like a combination of <code>ParFuture</code> and <code>ParIVar</code>
 from the abstract-par package. It captures the interface of
 concurrency monads in terms of how they can operate on shared
 state.
</p><p>There are a few notable differences: firstly, <code>Par</code> imposes
 <code>NFData</code> constraints on everything, as it achieves its speed-up by
 forcing evaluation in separate threads. <code>MonadConc</code> doesn't do
 that, and so you need to be careful about where evaluation occurs,
 just like with <code>MVar</code>s. Secondly, this builds on futures by
 allowing <code>CVar</code>s which threads can read from and write to, possibly
 multiple times, whereas with the <code>Par</code> monads it is illegal to
 write multiple times to the same <code>IVar</code> (or to non-blockingly read
 from it), which removes the possibility of data races.
</p><p>Every <code>MonadConc</code> has an associated <code><a href="Control-Monad-STM-Class.html#t:MonadSTM">MonadSTM</a></code>, transactions of
 which can be run atomically.
</p><p>A minimal implementation consists of <code><a href="Control-Monad-Conc-Class.html#v:fork">fork</a></code>, <code><a href="Control-Monad-Conc-Class.html#v:newEmptyCVar">newEmptyCVar</a></code>,
 <code><a href="Control-Monad-Conc-Class.html#v:tryPutCVar">tryPutCVar</a></code>, and <code><a href="Control-Monad-Conc-Class.html#v:tryTakeCVar">tryTakeCVar</a></code>. The default implementations of
 <code><a href="Control-Monad-Conc-Class.html#v:takeCVar">takeCVar</a></code> and <code><a href="Control-Monad-Conc-Class.html#v:putCVar">putCVar</a></code>, however, are very inefficient, and should
 probably always be overridden to make use of
 implementation-specific blocking functionality.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:STMLike" class="def">STMLike</a> m :: * -&gt; *<a href="src/Control-Monad-Conc-Class.html#STMLike" class="link">Source</a></p><div class="doc"><p>The associated <code><a href="Control-Monad-STM-Class.html#t:MonadSTM">MonadSTM</a></code> for this class.
</p></div><p class="src"><span class="keyword">type</span> <a name="t:CVar" class="def">CVar</a> m :: * -&gt; *<a href="src/Control-Monad-Conc-Class.html#CVar" class="link">Source</a></p><div class="doc"><p>The mutable reference type. This may contain one value at a
 time, attempting to read or take from an &quot;empty&quot; <code>CVar</code> will
 block until it is full, and attempting to put to a &quot;full&quot;
 <code>CVar</code> will block until it is empty.
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:fork" class="def">fork</a> :: m () -&gt; m ()<a href="src/Control-Monad-Conc-Class.html#fork" class="link">Source</a></p><div class="doc"><p>Fork a computation to happen concurrently. Communication may
 happen over <code>CVar</code>s.
</p></div><p class="src"><a name="v:spawn" class="def">spawn</a> ::  m a -&gt; m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)<a href="src/Control-Monad-Conc-Class.html#spawn" class="link">Source</a></p><div class="doc"><p>Create a concurrent computation for the provided action, and
 return a <code>CVar</code> which can be used to query the result.
</p><pre> spawn ma = do
   cvar &lt;- newEmptyCVar
   fork $ ma &gt;&gt;= putCVar cvar
   return cvar
</pre></div><p class="src"><a name="v:newEmptyCVar" class="def">newEmptyCVar</a> ::  m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)<a href="src/Control-Monad-Conc-Class.html#newEmptyCVar" class="link">Source</a></p><div class="doc"><p>Create a new empty <code>CVar</code>.
</p></div><p class="src"><a name="v:putCVar" class="def">putCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m ()<a href="src/Control-Monad-Conc-Class.html#putCVar" class="link">Source</a></p><div class="doc"><p>Put a value into a <code>CVar</code>. If there is already a value there,
 this will block until that value has been taken, at which point
 the value will be stored.
</p><pre> putCVar cvar a = tryPutCVar cvar a &gt;&gt;= \b -&gt; unless b $ putCVar cvar a
</pre></div><p class="src"><a name="v:tryPutCVar" class="def">tryPutCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m Bool<a href="src/Control-Monad-Conc-Class.html#tryPutCVar" class="link">Source</a></p><div class="doc"><p>Attempt to put a value in a <code>CVar</code>, returning <code>True</code> (and
 filling the <code>CVar</code>) if there was nothing there, otherwise
 returning <code>False</code>.
</p></div><p class="src"><a name="v:readCVar" class="def">readCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#readCVar" class="link">Source</a></p><div class="doc"><p>Block until a value is present in the <code>CVar</code>, and then return
 it. As with <code>readMVar</code>, this does not &quot;remove&quot; the value,
 multiple reads are possible.
</p></div><p class="src"><a name="v:takeCVar" class="def">takeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#takeCVar" class="link">Source</a></p><div class="doc"><p>Take a value from a <code>CVar</code>. This &quot;empties&quot; the <code>CVar</code>,
 allowing a new value to be put in. This will block if there is no
 value in the <code>CVar</code> already, until one has been put.
</p><pre> takeCVar cvar = tryTakeCVar cvar &gt;&gt;= maybe (takeCVar cvar) return
</pre></div><p class="src"><a name="v:tryTakeCVar" class="def">tryTakeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m (Maybe a)<a href="src/Control-Monad-Conc-Class.html#tryTakeCVar" class="link">Source</a></p><div class="doc"><p>Attempt to take a value from a <code>CVar</code>, returning a <code>Just</code> (and
 emptying the <code>CVar</code>) if there was something there, otherwise
 returning <code>Nothing</code>.
</p></div><p class="src"><a name="v:atomically" class="def">atomically</a> ::  <a href="Control-Monad-Conc-Class.html#t:STMLike">STMLike</a> m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#atomically" class="link">Source</a></p><div class="doc"><p>Perform a series of STM actions atomically.
</p></div><p class="src"><a name="v:_concNoTest" class="def">_concNoTest</a> ::  m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#_concNoTest" class="link">Source</a></p><div class="doc"><p>Runs its argument, just as if the <code>_concNoTest</code> weren't there.
</p><pre> _concNoTest x = x
</pre><p>This function is purely for testing purposes, and indicates that
 it's not worth considering more than one schedule here. This is
 useful if you have some larger computation built up out of
 subcomputations which you have already got tests for: you only
 want to consider what's unique to the large component.
</p><p>The test runner will report a failure if the argument fails.
</p><p>Note that inappropriate use of <code>_concNoTest</code> can actually
 <em>suppress</em> bugs! For this reason it is recommended to use it only
 for things which don't make use of any state from a larger
 scope. As a rule-of-thumb: if you can't define it as a top-level
 function taking no <code>CVar</code> arguments, you probably shouldn't
 <code>_concNoTest</code> it.
</p></div></div><div class="subs instances"><p id="control.i:MonadConc" class="caption collapser" onclick="toggleSection('i:MonadConc')">Instances</p><div id="section.i:MonadConc" class="show"><table><tr><td class="src"><a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> IO</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> (<a href="Test-DejaFu-Deterministic.html#t:Conc">Conc</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> (<a href="Test-DejaFu-Deterministic-IO.html#t:ConcIO">ConcIO</a> t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>