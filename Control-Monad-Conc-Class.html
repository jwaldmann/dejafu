<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.Conc.Class</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-Conc-Class.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Monad-Conc-Class.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">dejafu-0.0.0.0: Overloadable primitives for testable, potentially non-deterministic, concurrency.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Control.Monad.Conc.Class</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Utilities
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module captures in a typeclass the interface of concurrency
 monads.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (Monad m, MonadCatch m, MonadThrow m, MonadMask m, <a href="Control-Monad-STM-Class.html#t:MonadSTM">MonadSTM</a> (<a href="Control-Monad-Conc-Class.html#t:STMLike">STMLike</a> m), Eq (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m), Show (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)) =&gt; <a href="#t:MonadConc">MonadConc</a> m  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:STMLike">STMLike</a> m :: * -&gt; *</li><li><span class="keyword">type</span> <a href="#t:CVar">CVar</a> m :: * -&gt; *</li><li><span class="keyword">type</span> <a href="#t:ThreadId">ThreadId</a> m :: *</li><li><a href="#v:fork">fork</a> :: m () -&gt; m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)</li><li><a href="#v:forkWithUnmask">forkWithUnmask</a> :: ((<span class="keyword">forall</span> a.  m a -&gt; m a) -&gt; m ()) -&gt; m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)</li><li><a href="#v:myThreadId">myThreadId</a> :: m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)</li><li><a href="#v:newEmptyCVar">newEmptyCVar</a> ::  m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)</li><li><a href="#v:putCVar">putCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m ()</li><li><a href="#v:tryPutCVar">tryPutCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m Bool</li><li><a href="#v:readCVar">readCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a</li><li><a href="#v:takeCVar">takeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a</li><li><a href="#v:tryTakeCVar">tryTakeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m (Maybe a)</li><li><a href="#v:atomically">atomically</a> ::  <a href="Control-Monad-Conc-Class.html#t:STMLike">STMLike</a> m a -&gt; m a</li><li><a href="#v:throw">throw</a> :: Exception e =&gt; e -&gt; m a</li><li><a href="#v:catch">catch</a> :: Exception e =&gt; m a -&gt; (e -&gt; m a) -&gt; m a</li><li><a href="#v:throwTo">throwTo</a> :: Exception e =&gt; <a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m =&gt; e -&gt; m ()</li><li><a href="#v:mask">mask</a> ::  ((<span class="keyword">forall</span> a.  m a -&gt; m a) -&gt; m b) -&gt; m b</li><li><a href="#v:uninterruptibleMask">uninterruptibleMask</a> ::  ((<span class="keyword">forall</span> a.  m a -&gt; m a) -&gt; m b) -&gt; m b</li><li><a href="#v:_concNoTest">_concNoTest</a> ::  m a -&gt; m a</li></ul></li><li class="src short"><a href="#v:spawn">spawn</a> :: <a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> m =&gt; m a -&gt; m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)</li><li class="src short"><a href="#v:forkFinally">forkFinally</a> :: <a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> m =&gt; m a -&gt; (Either SomeException a -&gt; m ()) -&gt; m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)</li><li class="src short"><a href="#v:killThread">killThread</a> :: <a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> m =&gt; <a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m =&gt; m ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> (Monad m, MonadCatch m, MonadThrow m, MonadMask m, <a href="Control-Monad-STM-Class.html#t:MonadSTM">MonadSTM</a> (<a href="Control-Monad-Conc-Class.html#t:STMLike">STMLike</a> m), Eq (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m), Show (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)) =&gt; <a name="t:MonadConc" class="def">MonadConc</a> m  <span class="keyword">where</span><a href="src/Control-Monad-Conc-Class.html#MonadConc" class="link">Source</a></p><div class="doc"><p><code>MonadConc</code> is like a combination of <code>ParFuture</code> and <code>ParIVar</code>
 from the abstract-par package. It captures the interface of
 concurrency monads in terms of how they can operate on shared
 state.
</p><p>There are a few notable differences: firstly, <code>Par</code> imposes
 <code>NFData</code> constraints on everything, as it achieves its speed-up by
 forcing evaluation in separate threads. <code>MonadConc</code> doesn't do
 that, and so you need to be careful about where evaluation occurs,
 just like with <code>MVar</code>s. Secondly, this builds on futures by
 allowing <code>CVar</code>s which threads can read from and write to, possibly
 multiple times, whereas with the <code>Par</code> monads it is illegal to
 write multiple times to the same <code>IVar</code> (or to non-blockingly read
 from it), which removes the possibility of data races.
</p><p>Every <code>MonadConc</code> has an associated <code><a href="Control-Monad-STM-Class.html#t:MonadSTM">MonadSTM</a></code>, transactions of
 which can be run atomically.
</p><p>A minimal implementation consists of <code><a href="Control-Monad-Conc-Class.html#v:fork">fork</a></code>, <code><a href="Control-Monad-Conc-Class.html#v:newEmptyCVar">newEmptyCVar</a></code>,
 <code><a href="Control-Monad-Conc-Class.html#v:tryPutCVar">tryPutCVar</a></code>, and <code><a href="Control-Monad-Conc-Class.html#v:tryTakeCVar">tryTakeCVar</a></code>. The default implementations of
 <code><a href="Control-Monad-Conc-Class.html#v:takeCVar">takeCVar</a></code> and <code><a href="Control-Monad-Conc-Class.html#v:putCVar">putCVar</a></code>, however, are very inefficient, and should
 probably always be overridden to make use of
 implementation-specific blocking functionality.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:STMLike" class="def">STMLike</a> m :: * -&gt; *<a href="src/Control-Monad-Conc-Class.html#STMLike" class="link">Source</a></p><div class="doc"><p>The associated <code><a href="Control-Monad-STM-Class.html#t:MonadSTM">MonadSTM</a></code> for this class.
</p></div><p class="src"><span class="keyword">type</span> <a name="t:CVar" class="def">CVar</a> m :: * -&gt; *<a href="src/Control-Monad-Conc-Class.html#CVar" class="link">Source</a></p><div class="doc"><p>The mutable reference type. This may contain one value at a
 time, attempting to read or take from an &quot;empty&quot; <code>CVar</code> will
 block until it is full, and attempting to put to a &quot;full&quot;
 <code>CVar</code> will block until it is empty.
</p></div><p class="src"><span class="keyword">type</span> <a name="t:ThreadId" class="def">ThreadId</a> m :: *<a href="src/Control-Monad-Conc-Class.html#ThreadId" class="link">Source</a></p><div class="doc"><p>An abstract handle to a thread
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:fork" class="def">fork</a> :: m () -&gt; m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)<a href="src/Control-Monad-Conc-Class.html#fork" class="link">Source</a></p><div class="doc"><p>Fork a computation to happen concurrently. Communication may
 happen over <code>CVar</code>s.
</p></div><p class="src"><a name="v:forkWithUnmask" class="def">forkWithUnmask</a> :: ((<span class="keyword">forall</span> a.  m a -&gt; m a) -&gt; m ()) -&gt; m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)<a href="src/Control-Monad-Conc-Class.html#forkWithUnmask" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Control-Monad-Conc-Class.html#v:fork">fork</a></code>, but the child thread is passed a function that can
 be used to unmask asynchronous exceptions. This function should
 not be used within a <code><a href="Control-Monad-Conc-Class.html#v:mask">mask</a></code> or <code><a href="Control-Monad-Conc-Class.html#v:uninterruptibleMask">uninterruptibleMask</a></code>.
</p></div><p class="src"><a name="v:myThreadId" class="def">myThreadId</a> :: m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)<a href="src/Control-Monad-Conc-Class.html#myThreadId" class="link">Source</a></p><div class="doc"><p>Get the <code>ThreadId</code> of the current thread.
</p></div><p class="src"><a name="v:newEmptyCVar" class="def">newEmptyCVar</a> ::  m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)<a href="src/Control-Monad-Conc-Class.html#newEmptyCVar" class="link">Source</a></p><div class="doc"><p>Create a new empty <code>CVar</code>.
</p></div><p class="src"><a name="v:putCVar" class="def">putCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m ()<a href="src/Control-Monad-Conc-Class.html#putCVar" class="link">Source</a></p><div class="doc"><p>Put a value into a <code>CVar</code>. If there is already a value there,
 this will block until that value has been taken, at which point
 the value will be stored.
</p><pre> putCVar cvar a = tryPutCVar cvar a &gt;&gt;= \b -&gt; unless b $ putCVar cvar a
</pre></div><p class="src"><a name="v:tryPutCVar" class="def">tryPutCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; a -&gt; m Bool<a href="src/Control-Monad-Conc-Class.html#tryPutCVar" class="link">Source</a></p><div class="doc"><p>Attempt to put a value in a <code>CVar</code>, returning <code>True</code> (and
 filling the <code>CVar</code>) if there was nothing there, otherwise
 returning <code>False</code>.
</p></div><p class="src"><a name="v:readCVar" class="def">readCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#readCVar" class="link">Source</a></p><div class="doc"><p>Block until a value is present in the <code>CVar</code>, and then return
 it. As with <code>readMVar</code>, this does not &quot;remove&quot; the value,
 multiple reads are possible.
</p></div><p class="src"><a name="v:takeCVar" class="def">takeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#takeCVar" class="link">Source</a></p><div class="doc"><p>Take a value from a <code>CVar</code>. This &quot;empties&quot; the <code>CVar</code>,
 allowing a new value to be put in. This will block if there is no
 value in the <code>CVar</code> already, until one has been put.
</p><pre> takeCVar cvar = tryTakeCVar cvar &gt;&gt;= maybe (takeCVar cvar) return
</pre></div><p class="src"><a name="v:tryTakeCVar" class="def">tryTakeCVar</a> ::  <a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a -&gt; m (Maybe a)<a href="src/Control-Monad-Conc-Class.html#tryTakeCVar" class="link">Source</a></p><div class="doc"><p>Attempt to take a value from a <code>CVar</code>, returning a <code>Just</code> (and
 emptying the <code>CVar</code>) if there was something there, otherwise
 returning <code>Nothing</code>.
</p></div><p class="src"><a name="v:atomically" class="def">atomically</a> ::  <a href="Control-Monad-Conc-Class.html#t:STMLike">STMLike</a> m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#atomically" class="link">Source</a></p><div class="doc"><p>Perform a series of STM actions atomically.
</p></div><p class="src"><a name="v:throw" class="def">throw</a> :: Exception e =&gt; e -&gt; m a<a href="src/Control-Monad-Conc-Class.html#throw" class="link">Source</a></p><div class="doc"><p>Throw an exception. This will &quot;bubble up&quot; looking for an
 exception handler capable of dealing with it and, if one is not
 found, the thread is killed.
</p><pre> throw = Control.Monad.Catch.throwM
</pre></div><p class="src"><a name="v:catch" class="def">catch</a> :: Exception e =&gt; m a -&gt; (e -&gt; m a) -&gt; m a<a href="src/Control-Monad-Conc-Class.html#catch" class="link">Source</a></p><div class="doc"><p>Catch an exception. This is only required to be able to catch
 exceptions raised by <code><a href="Control-Monad-Conc-Class.html#v:throw">throw</a></code>, unlike the more general
 Control.Exception.catch function. If you need to be able to catch
 <em>all</em> errors, you will have to use <code>IO</code>.
</p><pre> catch = Control.Monad.Catch.catch
</pre></div><p class="src"><a name="v:throwTo" class="def">throwTo</a> :: Exception e =&gt; <a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m =&gt; e -&gt; m ()<a href="src/Control-Monad-Conc-Class.html#throwTo" class="link">Source</a></p><div class="doc"><p>Throw an exception to the target thread. This blocks until the
 exception is delivered, and it is just as if the target thread
 had raised it with <code><a href="Control-Monad-Conc-Class.html#v:throw">throw</a></code>. This can interrupt a blocked action.
</p></div><p class="src"><a name="v:mask" class="def">mask</a> ::  ((<span class="keyword">forall</span> a.  m a -&gt; m a) -&gt; m b) -&gt; m b<a href="src/Control-Monad-Conc-Class.html#mask" class="link">Source</a></p><div class="doc"><p>Executes a computation with asynchronous exceptions
 <em>masked</em>. That is, any thread which attempts to raise an
 exception in the current thread with <code><a href="Control-Monad-Conc-Class.html#v:throwTo">throwTo</a></code> will be blocked
 until asynchronous exceptions are unmasked again.
</p><p>The argument passed to mask is a function that takes as its
 argument another function, which can be used to restore the
 prevailing masking state within the context of the masked
 computation. This function should not be used within an
 <code><a href="Control-Monad-Conc-Class.html#v:uninterruptibleMask">uninterruptibleMask</a></code>.
</p><pre> mask = Control.Monad.Catch.mask
</pre></div><p class="src"><a name="v:uninterruptibleMask" class="def">uninterruptibleMask</a> ::  ((<span class="keyword">forall</span> a.  m a -&gt; m a) -&gt; m b) -&gt; m b<a href="src/Control-Monad-Conc-Class.html#uninterruptibleMask" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Control-Monad-Conc-Class.html#v:mask">mask</a></code>, but the masked computation is not
 interruptible. THIS SHOULD BE USED WITH GREAT CARE, because if a
 thread executing in <code><a href="Control-Monad-Conc-Class.html#v:uninterruptibleMask">uninterruptibleMask</a></code> blocks for any reason,
 then the thread (and possibly the program, if this is the main
 thread) will be unresponsive and unkillable. This function should
 only be necessary if you need to mask exceptions around an
 interruptible operation, and you can guarantee that the
 interruptible operation will only block for a short period of
 time. The supplied unmasking function should not be used within a
 <code><a href="Control-Monad-Conc-Class.html#v:mask">mask</a></code>.
</p><pre> uninterruptibleMask = Control.Monad.Catch.uninterruptibleMask
</pre></div><p class="src"><a name="v:_concNoTest" class="def">_concNoTest</a> ::  m a -&gt; m a<a href="src/Control-Monad-Conc-Class.html#_concNoTest" class="link">Source</a></p><div class="doc"><p>Runs its argument, just as if the <code>_concNoTest</code> weren't there.
</p><pre> _concNoTest x = x
</pre><p>This function is purely for testing purposes, and indicates that
 it's not worth considering more than one schedule here. This is
 useful if you have some larger computation built up out of
 subcomputations which you have already got tests for: you only
 want to consider what's unique to the large component.
</p><p>The test runner will report a failure if the argument fails.
</p><p>Note that inappropriate use of <code>_concNoTest</code> can actually
 <em>suppress</em> bugs! For this reason it is recommended to use it only
 for things which don't make use of any state from a larger
 scope. As a rule-of-thumb: if you can't define it as a top-level
 function taking no <code>CVar</code> arguments, you probably shouldn't
 <code>_concNoTest</code> it.
</p></div></div><div class="subs instances"><p id="control.i:MonadConc" class="caption collapser" onclick="toggleSection('i:MonadConc')">Instances</p><div id="section.i:MonadConc" class="show"><table><tr><td class="src"><a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> IO</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> (<a href="Test-DejaFu-Deterministic.html#t:Conc">Conc</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> (<a href="Test-DejaFu-Deterministic-IO.html#t:ConcIO">ConcIO</a> t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:1">Utilities
</h1><div class="top"><p class="src"><a name="v:spawn" class="def">spawn</a> :: <a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> m =&gt; m a -&gt; m (<a href="Control-Monad-Conc-Class.html#t:CVar">CVar</a> m a)<a href="src/Control-Monad-Conc-Class.html#spawn" class="link">Source</a></p><div class="doc"><p>Create a concurrent computation for the provided action, and
 return a <code>CVar</code> which can be used to query the result.
</p></div></div><div class="top"><p class="src"><a name="v:forkFinally" class="def">forkFinally</a> :: <a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> m =&gt; m a -&gt; (Either SomeException a -&gt; m ()) -&gt; m (<a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m)<a href="src/Control-Monad-Conc-Class.html#forkFinally" class="link">Source</a></p><div class="doc"><p>Fork a thread and call the supplied function when the thread is
 about to terminate, with an exception or a returned value. The
 function is called with asynchronous exceptions masked.
</p><p>This function is useful for informing the parent when a child
 terminates, for example.
</p></div></div><div class="top"><p class="src"><a name="v:killThread" class="def">killThread</a> :: <a href="Control-Monad-Conc-Class.html#t:MonadConc">MonadConc</a> m =&gt; <a href="Control-Monad-Conc-Class.html#t:ThreadId">ThreadId</a> m =&gt; m ()<a href="src/Control-Monad-Conc-Class.html#killThread" class="link">Source</a></p><div class="doc"><p>Raise the <code>ThreadKilled</code> exception in the target thread. Note
 that if the thread is prepared to catch this exception, it won't
 actually kill it.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>